// Generated by LiveScript 1.2.0
(function(){
  var RTCPeerConnection, RTCSessionDescription, RTCIceCandidate, isFirefox, isChrome, STUN, TURN, iceServers, optionalArgument, VideoChat, SignallerSocketIO, Peer;
  RTCPeerConnection = window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
  RTCSessionDescription = window.mozRTCSessionDescription || window.RTCSessionDescription;
  RTCIceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate;
  navigator.getUserMedia = navigator.mozGetUserMedia || navigator.webkitGetUserMedia;
  isFirefox = !!navigator.mozGetUserMedia;
  isChrome = !!navigator.webkitGetUserMedia;
  STUN = {
    url: isChrome ? 'stun:stun.l.google.com:19302' : 'stun:23.21.150.121'
  };
  TURN = {
    url: 'turn:homeo@turn.bistri.com:80',
    credential: 'homeo'
  };
  iceServers = {
    iceServers: [STUN]
  };
  if (isChrome) {
    if (parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2] >= 28)) {
      TURN = {
        url: 'turn:turn.bistri.com:80',
        credential: 'homeo',
        username: 'homeo'
      };
    }
    iceServers.iceServers = [STUN, TURN];
  }
  optionalArgument = {
    optional: [{
      DtlsSrtpKeyAgreement: true
    }]
  };
  window.VideoChat = VideoChat = (function(){
    VideoChat.displayName = 'VideoChat';
    var createCamNode, prototype = VideoChat.prototype, constructor = VideoChat;
    function VideoChat(){
      var self;
      this.user = {
        isHost: false
      };
      self = this;
      window.addEventListener('beforeunload', function(){
        self.part();
      });
    }
    prototype.onaddstream = function(video, stream){};
    prototype.onuserleft = function(userId){};
    createCamNode = function(id, stream){
      var x$, video;
      x$ = video = document.createElement('video');
      x$.id = id;
      x$[isFirefox ? 'mozSrcObject' : 'src'] = isFirefox
        ? stream
        : window.webkitURL.createObjectURL(stream);
      x$.autoplay = true;
      x$.controls = false;
      x$.play();
      return x$;
    };
    prototype.buildStreamHandler = function(userId, callback){
      var self;
      self = this;
      return function(stream){
        var node, x$;
        stream.onended = function(){
          self.onuserleft(userId);
        };
        self.stream = stream;
        node = createCamNode(userId, stream);
        if (userId === self.user.id) {
          x$ = node;
          x$.muted = true;
          x$.volume = 0;
        }
        self.onaddstream(node, stream);
        if (typeof callback === 'function') {
          callback(stream);
        }
      };
    };
    prototype._getUserMedia = function(callback){
      var constraints, onstream, onerror;
      constraints = {
        audio: true,
        video: true
      };
      onstream = this.buildStreamHandler(this.user.id, callback);
      onerror = function(it){
        console.error(it);
      };
      navigator.getUserMedia(constraints, onstream, onerror);
    };
    prototype.setSignaller = function(it){
      return this.sig = it;
    };
    prototype.join = function(roomid){
      var self;
      if (this.sig == null) {
        console.error('No signaller set!');
        return;
      }
      roomid = roomid || getToken();
      self = this;
      this._getUserMedia(function(stream){
        self.stream = stream;
        self.sig.signal('join', {
          roomid: roomid
        }, function(exists){
          self.user.isHost = !exists;
        });
      });
    };
    prototype.part = function(){
      var key, ref$, peer;
      if (this.sig == null) {
        console.error('No signaller set!');
        return;
      }
      for (key in ref$ = this.sig.peers) {
        peer = ref$[key];
        this.sig.signal('part', {
          to: peer.userId
        });
      }
      if ((ref$ = this.stream) != null) {
        ref$.stop();
      }
    };
    return VideoChat;
  }());
  window.SignallerSocketIO = SignallerSocketIO = (function(){
    SignallerSocketIO.displayName = 'SignallerSocketIO';
    var prototype = SignallerSocketIO.prototype, constructor = SignallerSocketIO;
    function SignallerSocketIO(vc){
      this.vc = vc;
      this.peers = {};
    }
    prototype.connect = function(address, callback){
      var self, socket, x$;
      if (typeof io == 'undefined' || io === null) {
        alert('Unable to connect to signalling server.\nChances are everything is OK on your end and the server is just down for some reason.\nIf it\'s not up again soon, email me at yousef@amar.io.');
        return;
      }
      self = this;
      socket = io.connect(address);
      this.signal = function(event, data, callback){
        if (self.vc.user.id == null) {
          console.error('No UID assigned by server!');
          return;
        }
        data = data || {};
        console.log('> ', event, data);
        socket.emit(event, data, callback);
      };
      x$ = socket;
      x$.on('uid', function(uid){
        console.log('< ', 'uid', uid);
        self.vc.user.id = uid;
        callback(uid);
      });
      x$.on('join', function(userId){
        var key, ref$, peer, x$;
        console.log('< ', 'join', userId);
        if (self.vc.user.isHost) {
          for (key in ref$ = self.peers) {
            peer = ref$[key];
            self.signal('new', {
              to: peer.userId,
              'new': userId
            });
          }
        }
        x$ = self.peers[userId] = new Peer(userId, self);
        x$.addStream(self.vc.stream);
        x$.createOffer();
      });
      x$.on('part', function(userId){
        console.log('< ', 'part', userId);
        self.vc.onuserleft(userId);
        return;
      });
      x$.on('sdp', function(data){
        var sdp, x$;
        console.log('< ', 'sdp', data);
        sdp = data.sdp;
        if (sdp.type === 'offer') {
          x$ = self.peers[data.userId] = new Peer(data.from, self);
          x$.addStream(self.vc.stream);
          x$.createAnswer(sdp);
        }
        if (sdp.type === 'answer') {
          self.peers[data.from].setRemoteDescription(sdp);
        }
      });
      x$.on('ice', function(data){
        var ref$;
        console.log('< ', 'ice', data);
        if ((ref$ = self.peers[data.from]) != null) {
          ref$.addIceCandidate(data.candidate);
        }
      });
    };
    prototype.signal = function(){
      console.error('No signalling function set!');
    };
    return SignallerSocketIO;
  }());
  return Peer = (function(){
    Peer.displayName = 'Peer';
    var mediaConstraints, onSdpSuccess, onSdpError, prototype = Peer.prototype, constructor = Peer;
    function Peer(userId, sig){
      var conn, self;
      this.userId = userId;
      this.sig = sig;
      this.conn = conn = new RTCPeerConnection(iceServers, optionalArgument);
      self = this;
      conn.onaddstream = function(){
        var onstream;
        onstream = sig.vc.buildStreamHandler(userId);
        return function(event){
          onstream(event.stream);
        };
      }();
      conn.onicecandidate = function(event){
        if (!event.candidate) {
          self.onsdp(conn.localDescription, userId);
        } else {
          self.onicecandidate(event.candidate, userId);
        }
      };
      conn.ongatheringchange = function(event){
        event.currentTarget && event.currentTarget.iceGatheringState === 'complete' && self.onsdp(conn.localDescription, userId);
      };
    }
    prototype.addStream = function(it){
      this.conn.addStream(it);
    };
    mediaConstraints = {
      optional: [],
      mandatory: {
        OfferToReceiveAudio: true,
        OfferToReceiveVideo: true
      }
    };
    prototype.createOffer = function(){
      var self;
      self = this;
      this.conn.createOffer(function(sdp){
        self.conn.setLocalDescription(sdp);
        isFirefox && self.onsdp(sdp, self.userId);
      }, onSdpError, mediaConstraints);
    };
    prototype.createAnswer = function(sdp){
      var self;
      self = this;
      this.conn.setRemoteDescription(new RTCSessionDescription(sdp, onSdpSuccess, onSdpError));
      this.conn.createAnswer(function(sdp){
        self.conn.setLocalDescription(sdp);
        self.onsdp(sdp, self.userId);
      }, onSdpError, mediaConstraints);
    };
    prototype.setRemoteDescription = function(sdp){
      this.conn.setRemoteDescription(new RTCSessionDescription(sdp, onSdpSuccess, onSdpError));
    };
    prototype.addIceCandidate = function(candidate){
      this.conn.addIceCandidate(new RTCIceCandidate({
        sdpMLineIndex: candidate.sdpMLineIndex,
        candidate: candidate.candidate
      }));
    };
    prototype.onicecandidate = function(candidate, to){
      this.sig.signal('ice', {
        candidate: candidate,
        to: to
      });
    };
    prototype.onsdp = function(sdp, to){
      this.sig.signal('sdp', {
        sdp: sdp,
        to: to
      });
    };
    onSdpSuccess = function(){};
    onSdpError = function(it){
      console.error('sdp error:', it.name, it.message);
    };
    return Peer;
  }());
})();