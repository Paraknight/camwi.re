// Generated by LiveScript 1.2.0
(function(){
  var Signaler, RTCPeerConnection, RTCSessionDescription, RTCIceCandidate, isFirefox, isChrome, STUN, TURN, iceServers, optionalArgument, offerAnswerConstraints, getToken, onSdpSuccess, onSdpError, Offer, Answer, swap;
  window.Meeting = function(){
    var signaler, self, initSignaler, captureUserMedia;
    signaler = null;
    self = this;
    this.onmeeting = function(room){
      if (!self.detectedRoom) {
        self.detectedRoom = true;
        self.meet(room);
      }
    };
    initSignaler = function(){
      signaler = new Signaler(self);
    };
    captureUserMedia = function(callback){
      var constraints, onstream, onerror;
      constraints = {
        audio: true,
        video: true
      };
      onstream = function(stream){
        var video;
        stream.onended = function(){
          if (self.onuserleft) {
            self.onuserleft('self');
          }
        };
        self.stream = stream;
        video = document.createElement('video');
        video.id = 'self';
        video[isFirefox ? 'mozSrcObject' : 'src'] = isFirefox
          ? stream
          : window.webkitURL.createObjectURL(stream);
        video.autoplay = true;
        video.controls = false;
        video.muted = true;
        video.volume = 0;
        video.play();
        self.onaddstream({
          video: video,
          stream: stream,
          userid: 'self',
          type: 'local'
        });
        callback(stream);
      };
      onerror = function(it){
        console.error(it);
      };
      navigator.getUserMedia(constraints, onstream, onerror);
    };
    this.setup = function(roomid){
      captureUserMedia(function(){
        !signaler && initSignaler();
        signaler.broadcast({
          roomid: roomid
        });
      });
    };
    this.meet = function(room){
      captureUserMedia(function(){
        !signaler && initSignaler();
        signaler.join({
          to: room.userid,
          roomid: room.roomid
        });
      });
    };
    this.check = initSignaler;
  };
  Signaler = function(root){
    var userid, signaler, peers, participants, participationRequest, createOffer, repeatedlyCreateOffer, options, leaveRoom, socket;
    userid = root.userid || getToken();
    signaler = this;
    peers = {};
    participants = {};
    this.onmessage = function(message){
      if (message.roomid && message.broadcasting && !signaler.sentParticipationRequest) {
        root.onmeeting(message);
      }
      if (message.sdp && message.to == userid) {
        this.onsdp(message);
      }
      if (message.candidate && message.to == userid) {
        this.onice(message);
      }
      if (message.participationRequest && message.to == userid) {
        participationRequest(message.userid);
      }
      if (message.conferencing && message.newcomer != userid && !!participants[message.newcomer] == false) {
        participants[message.newcomer] = message.newcomer;
        root.stream && signaler.signal({
          participationRequest: true,
          to: message.newcomer
        });
      }
    };
    participationRequest = function(_userid){
      if (!signaler.creatingOffer) {
        signaler.creatingOffer = true;
        createOffer(_userid);
        setTimeout(function(){
          signaler.creatingOffer = false;
          if (signaler.participants && signaler.participants.length) {
            repeatedlyCreateOffer();
          }
        }, 1000);
      } else {
        if (!signaler.participants) {
          signaler.participants = [];
        }
        signaler.participants[signaler.participants.length] = _userid;
      }
    };
    createOffer = function(unto){
      var _options;
      _options = options;
      _options.to = unto;
      _options.stream = root.stream;
      peers[unto] = Offer.createOffer(_options);
    };
    repeatedlyCreateOffer = function(){
      var firstParticipant;
      firstParticipant = signaler.participants[0];
      if (!firstParticipant) {
        return;
      }
      signaler.creatingOffer = true;
      createOffer(firstParticipant);
      delete signaler.participants[0];
      signaler.participants = swap(signaler.participants);
      setTimeout(function(){
        signaler.creatingOffer = false;
        if (signaler.participants[0]) {
          repeatedlyCreateOffer();
        }
      }, 1000);
    };
    this.onsdp = function(message){
      var sdp, _options;
      sdp = message.sdp;
      if (sdp.type === 'offer') {
        _options = options;
        _options.stream = root.stream;
        _options.sdp = sdp;
        _options.to = message.userid;
        peers[message.userid] = Answer.createAnswer(_options);
      }
      if (sdp.type === 'answer') {
        peers[message.userid].setRemoteDescription(sdp);
      }
    };
    this.onice = function(message){
      var peer;
      peer = peers[message.userid];
      if (peer) {
        peer.addIceCandidate(message.candidate);
      }
    };
    options = {
      onsdp: function(sdp, to){
        signaler.signal({
          sdp: sdp,
          to: to
        });
      },
      onicecandidate: function(candidate, to){
        signaler.signal({
          candidate: candidate,
          to: to
        });
      },
      onaddstream: function(stream, _userid){
        var video, onRemoteStreamStartsFlowing, afterRemoteStreamStartedFlowing;
        stream.onended = function(){
          if (root.onuserleft) {
            root.onuserleft(_userid);
          }
        };
        video = document.createElement('video');
        video.id = _userid;
        video[isFirefox ? 'mozSrcObject' : 'src'] = isFirefox
          ? stream
          : window.webkitURL.createObjectURL(stream);
        video.autoplay = true;
        video.controls = false;
        video.play();
        onRemoteStreamStartsFlowing = function(){
          if (!(video.readyState <= HTMLMediaElement.HAVE_CURRENT_DATA || video.paused || video.currentTime <= 0)) {
            afterRemoteStreamStartedFlowing();
          } else {
            setTimeout(onRemoteStreamStartsFlowing, 300);
          }
        };
        afterRemoteStreamStartedFlowing = function(){
          signaler.isbroadcaster && signaler.signal({
            conferencing: true,
            newcomer: _userid
          });
          if (typeof root.onaddstream === 'function') {
            root.onaddstream({
              video: video,
              stream: stream,
              userid: _userid,
              type: 'remote'
            });
          }
        };
        return onRemoteStreamStartsFlowing();
      }
    };
    this.broadcast = function(_config){
      var transmit;
      signaler.roomid = _config.roomid || getToken();
      signaler.isbroadcaster = true;
      (transmit = function(){
        signaler.signal({
          roomid: signaler.roomid,
          broadcasting: true
        });
        if (!signaler.stopBroadcasting && !root.transmitOnce) {
          setTimeout(transmit, 3000);
        }
      })();
    };
    this.join = function(_config){
      signaler.roomid = _config.roomid;
      this.signal({
        to: _config.to,
        participationRequest: true
      });
      signaler.sentParticipationRequest = true;
    };
    window.onbeforeunload = function(){
      leaveRoom();
    };
    leaveRoom = function(){
      var ref$;
      signaler.signal({
        leaving: true
      });
      if (signaler.isbroadcaster) {
        signaler.stopBroadcasting = true;
      }
      if ((ref$ = root.stream) != null) {
        ref$.stop();
      }
    };
    root.leave = leaveRoom;
    socket = null;
    socket = root.openSignalingChannel(function(message){
      message = JSON.parse(message);
      console.log('< ', message);
      if (message.userid != userid) {
        if (!message.leaving) {
          signaler.onmessage(message);
        } else if (root.onuserleft) {
          root.onuserleft(message.userid);
        }
      }
    });
    this.signal = function(data){
      console.log('> ', data);
      data.userid = userid;
      socket.send(JSON.stringify(data));
    };
  };
  RTCPeerConnection = window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
  RTCSessionDescription = window.mozRTCSessionDescription || window.RTCSessionDescription;
  RTCIceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate;
  navigator.getUserMedia = navigator.mozGetUserMedia || navigator.webkitGetUserMedia;
  isFirefox = !!navigator.mozGetUserMedia;
  isChrome = !!navigator.webkitGetUserMedia;
  STUN = {
    url: isChrome ? 'stun:stun.l.google.com:19302' : 'stun:23.21.150.121'
  };
  TURN = {
    url: 'turn:homeo@turn.bistri.com:80',
    credential: 'homeo'
  };
  iceServers = {
    iceServers: [STUN]
  };
  if (isChrome) {
    if (parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2] >= 28)) {
      TURN = {
        url: 'turn:turn.bistri.com:80',
        credential: 'homeo',
        username: 'homeo'
      };
    }
    iceServers.iceServers = [STUN, TURN];
  }
  optionalArgument = {
    optional: [{
      DtlsSrtpKeyAgreement: true
    }]
  };
  offerAnswerConstraints = {
    optional: [],
    mandatory: {
      OfferToReceiveAudio: true,
      OfferToReceiveVideo: true
    }
  };
  getToken = function(){
    return Math.round(Math.random() * 9999999999) + 9999999999;
  };
  onSdpSuccess = function(){};
  onSdpError = function(it){
    console.error('sdp error:', it.name, it.message);
  };
  Offer = {
    createOffer: function(config){
      var peer, sdpCallback;
      peer = new RTCPeerConnection(iceServers, optionalArgument);
      if (config.stream) {
        peer.addStream(config.stream);
      }
      if (config.onaddstream) {
        peer.onaddstream = function(event){
          config.onaddstream(event.stream, config.to);
        };
      }
      peer.onicecandidate = function(event){
        if (!event.candidate) {
          sdpCallback();
        }
      };
      peer.ongatheringchange = function(event){
        if (event.currentTarget && event.currentTarget.iceGatheringState === 'complete') {
          sdpCallback();
        }
      };
      peer.createOffer(function(sdp){
        peer.setLocalDescription(sdp);
        if (isFirefox) {
          config.onsdp(sdp, config.to);
        }
      }, onSdpError, offerAnswerConstraints);
      sdpCallback = function(){
        config.onsdp(peer.localDescription, config.to);
      };
      this.peer = peer;
      return this;
    },
    setRemoteDescription: function(sdp){
      this.peer.setRemoteDescription(new RTCSessionDescription(sdp, onSdpSuccess, onSdpError));
    },
    addIceCandidate: function(candidate){
      this.peer.addIceCandidate(new RTCIceCandidate({
        sdpMLineIndex: candidate.sdpMLineIndex,
        candidate: candidate.candidate
      }));
    }
  };
  Answer = {
    createAnswer: function(config){
      var peer;
      peer = new RTCPeerConnection(iceServers, optionalArgument);
      if (config.stream) {
        peer.addStream(config.stream);
      }
      if (config.onaddstream) {
        peer.onaddstream = function(event){
          config.onaddstream(event.stream, config.to);
        };
      }
      peer.onicecandidate = function(event){
        config.onicecandidate(event.candidate, config.to);
      };
      peer.setRemoteDescription(new RTCSessionDescription(config.sdp, onSdpSuccess, onSdpError));
      peer.createAnswer(function(sdp){
        peer.setLocalDescription(sdp);
        config.onsdp(sdp, config.to);
      }, onSdpError, offerAnswerConstraints);
      this.peer = peer;
      return this;
    },
    addIceCandidate: function(candidate){
      this.peer.addIceCandidate(new RTCIceCandidate({
        sdpMLineIndex: candidate.sdpMLineIndex,
        candidate: candidate.candidate
      }));
    }
  };
  return swap = function(arr){
    var swapped, i$, len$, e;
    swapped = [];
    for (i$ = 0, len$ = arr.length; i$ < len$; ++i$) {
      e = arr[i$];
      if (e != null && e !== true) {
        swapped.push(i);
      }
    }
    return swapped;
  };
})();